# 详解AQS源代码

## 1.背景
使用多线程时，线程安全一直是一个令人头疼的问题。这一类的bug也比较难处理，今天分享一下aqs的源代码，
一起欣赏一下java大神Doug Lea写的代码，你会发现原来多线程的锁机制原来是很简单的。
>- 什么是AQS(AbstractQueuedSynchronizer):
>  AQS定义了一套多线程访问共享资源的同步器框架，是整个java.util.concurrent包的基石，Lock、ReadWriteLock、CountDowndLatch、CyclicBarrier、Semaphore、ThreadPoolExecutor等都是在AQS的基础上实现的。
>- ReentrantLock: 独占、可重入锁,用state变量记录某个线程获取独占锁的次数,获取锁时+1，释放锁时-1，在获取时会校验线程是否可以获取锁。
>- CountDownLatch: 共享锁，用state变量作为计数器，在初始化时指定。只要state还大于0，获取共享锁会因为失败而阻塞，直到计数器的值为0时，共享锁才允许获取，所有等待线程会被逐一唤醒。
>- Semaphore: 信号量，用state变量作为计数器，只有在大于0时允许线程进入。获取锁时-1，释放锁时+1。
>- ReadWriteLock: 读写锁，读锁是共享锁，写锁是独占锁

## 2.实现思路
问题：如何实现一个锁？

1.当一个线程获取对象锁之后，其余线程该如何处理？如何高效率存储？

2.在线程释放锁之后，阻塞线程如何高效拿到这个锁？

并发控制的核心是锁的获取与释放（acquire和release），锁的实现方式有很多种，AQS采用的是一种改进的CLH锁。
CLH锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。

## 3.源代码
   1. 公平锁：获取锁的顺序是按照线程加锁的顺序来分配的,即先来先得的FIFO先进先出顺序。优点：能够避免线程饥饿；缺点：性能不够好
   2. 非公平锁：一种获取锁的抢占机制,是随机获得锁的。优点：性能好；缺点：可能会产生线程饥饿问题

   - 关键方法：hasQueuedPredecessors
   
   如果hasQueuedPredecessors返回true，表示有其他线程先于当前线程等待获取锁，此时为了实现公平，保证等待时间最长的线程先获取到锁，不能执行当前线程。
   
   1)如果h==t成立，队列为空，无前驱节点，返回false。
   
   2）如果h!=t成立，从head节点的next是否为null，如果为null，返回true。什么情况下h!=t的同时h.next==null？？，
   有其他线程第一次正在入队时，可能会出现。见AQS的enq方法，compareAndSetHead(node)完成，还没执行tail = head语句时，此时tail=null,head=newNode,head.next-null。
   
   3）如果h!=t成立，从head节点的next是否不为null，则判断是否是当前线程，如果是返回false，否则有前驱节点，返回true




## 4.问题思考
1. 为什么涉及到线程操作都需要用for死循环，而不是if

2. 为什么unparkSuccessor唤醒时是从tail往前查找

3. 为什么AQS中的Node是双向链表，condition中的队列是单向链表
AQS同步队列要设计成双向的，是因为在同步队列中，节点唤醒是接力式的，由每一个节点唤醒它的下一个节点，如果是由next指针获取下一个节点，是有可能获取失败的，
因为虚拟队列每添加一个节点，是先用CAS把tail设置为新节点，然后才修改原tail的next指针到新节点的。
因此用next向后遍历是不安全的，但是如果在设置新节点为tail前，为新节点设置prev，则可以保证从tail往前遍历是安全的。
要安全的获取一个节点Node的下一个节点，先要看next是不是null，如果是null，还要从tail往前遍历看看能不能遍历到Node。
而等待队列就简单多了，等待的线程就是等待者，只负责等待，唤醒的线程就是唤醒者，只负责唤醒。
因此每次要执行唤醒操作的时候，直接唤醒等待队列的首节点就行了。等待队列的实现中不需要遍历队列，因此也不需要prev指针。
4. nonfairTryAcquire方法为什么没有用CAS设置state

## 5.阅读源码收获
>阅读底层优秀的源码我认为对于个人的代码能力有很大的提升，而且底层有很多优秀的设计模式和思想。

>今天讲解的AQS源码设计很精妙，要看懂大致套路并不困难，但是要完全领悟其中的一些细节是一件需要花功夫来仔细琢磨品味的事情，
>有些地方可以多考虑考虑李大爷这样写的原因。
>实际上concurrent包下包括ConcurrentHashMap这些类的实现都非常复杂，而且考虑非常精细。我觉得大家有空可以静下心来多学习学习，
>当你了解了底层代码，对于类的运用也会更加得心应手。
>
>最后，后续我如果有阅读到好的底层代码，还会分享给大家。
